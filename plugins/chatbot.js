const axios = require('axios');
const { cmd } = require('../command');
const config = require("../config");
const { setConfig, getConfig } = require("../lib/configdb");
const fs = require('fs');
const path = require('path');
const { downloadTempMedia, cleanupTemp } = require("../lib/media-utils");

const simulateTyping = async (conn, jid) => {
  await conn.sendPresenceUpdate('composing', jid);
  let stopped = false;
  const interval = setInterval(() => {
    if (!stopped) conn.sendPresenceUpdate('composing', jid);
  }, 5000);
  return () => {
    clearInterval(interval);
    conn.sendPresenceUpdate('paused', jid);
    stopped = true;
  };
};

const animatedTyping = async (conn, jid, msgKey) => {
  const emojis = ["üí≠", "üí¨", "‚úçÔ∏è"];
  let index = 0;
  let stopped = false;
  const interval = setInterval(() => {
    if (stopped) return;
    conn.sendMessage(jid, { react: { text: emojis[index], key: msgKey } });
    index = (index + 1) % emojis.length;
  }, 1000);
  return () => {
    clearInterval(interval);
    conn.sendMessage(jid, { react: { text: "ü§ñ", key: msgKey } });
    stopped = true;
  };
};

let AI_STATE = {
  IB: "false",
  GC: "false"
};

// Load saved state
(async () => {
  const saved = await getConfig("AI_STATE");
  if (saved) AI_STATE = JSON.parse(saved);
})();

// Main chatbot command (menu with image)
cmd({
  pattern: "chatbot",
  desc: "Control AI chatbot mode",
  category: "ai",
  filename: __filename,
  react: "ü§ñ"
}, async (conn, mek, m, { reply, isOwner }) => {
  if (!isOwner) return reply("‚ùå Only the bot owner can use this command.");

  const imageUrl = 'https://i.postimg.cc/rFV2pJW5/IMG-20250603-WA0017.jpg';
  const caption = `ü§ñ *Xylo AI Control Panel*

üì• PM: ${AI_STATE.IB === "true" ? "‚úÖ On" : "‚ùå Off"}
üë• Group: ${AI_STATE.GC === "true" ? "‚úÖ On" : "‚ùå Off"}

Reply with:
1 - Enable PM
2 - Enable GC
3 - Enable All
4 - Disable All`;

  await conn.sendMessage(m.chat, {
    image: { url: imageUrl },
    caption
  }, { quoted: m });

  const handler = async (res) => {
    const choice = res.message?.conversation?.trim();
    if (!["1", "2", "3", "4"].includes(choice)) return;

    switch (choice) {
      case "1": AI_STATE.IB = "true"; break;
      case "2": AI_STATE.GC = "true"; break;
      case "3": AI_STATE.IB = "true"; AI_STATE.GC = "true"; break;
      case "4": AI_STATE.IB = "false"; AI_STATE.GC = "false"; break;
    }

    await setConfig("AI_STATE", JSON.stringify(AI_STATE));
    await conn.sendMessage(m.chat, {
      text: `‚úÖ Xylo AI updated:

üì• PM: ${AI_STATE.IB === "true" ? "‚úÖ On" : "‚ùå Off"}
üë• Group: ${AI_STATE.GC === "true" ? "‚úÖ On" : "‚ùå Off"}`
    }, { quoted: res });
  };

  conn.ev.once('messages.upsert', async ({ messages }) => {
    const res = messages[0];
    if (res.key?.remoteJid !== m.key.remoteJid || res.key.fromMe) return;
    await handler(res);
  });
});

// AI response handler
cmd({
  on: "body"
}, async (conn, m, store, { from, body, isGroup }) => {
  try {
    if (m.key.fromMe || body?.startsWith(config.PREFIX)) return;

    const botJid = conn.user.id.split(':')[0] + '@s.whatsapp.net';
    const contextInfo = m?.message?.extendedTextMessage?.contextInfo || {};
    const isMentioned = contextInfo.mentionedJid?.includes(botJid);
    const isQuoted = contextInfo.participant === botJid || contextInfo.stanzaId === m.key.id;

    const allowed = isGroup ? AI_STATE.GC === "true" : AI_STATE.IB === "true";
    if (!allowed || (!isMentioned && !isQuoted && isGroup)) return;

    const realSender = m.key.participant || m.key.remoteJid;
    const userId = realSender.split("@")[0];

    if (body.toLowerCase().startsWith("draw ")) {
      await conn.sendMessage(from, { react: { text: "üé®", key: m.key } });
      const prompt = body.slice(5).trim();
      const { data: draw } = await axios.post('https://xylo-ai.onrender.com/draw', { prompt });
      const imgPath = await downloadTempMedia(draw.imageUrl, 'xylo_img.jpg');
      await conn.sendMessage(from, {
        image: fs.readFileSync(imgPath),
        caption: "üñºÔ∏è Generated by ùïè è ü·¥è"
      }, { quoted: m });
      cleanupTemp(imgPath);
      return;
    }

    const stopEmoji = await animatedTyping(conn, from, m.key);
    const stopTyping = await simulateTyping(conn, from);

    const res = await axios.post('https://xylo-ai.onrender.com/ask', {
      userId,
      message: body
    });

    const replyText = res.data?.reply;
    await conn.sendMessage(from, {
      text: replyText || "‚ö†Ô∏è I heard you, but couldn't generate a reply."
    }, { quoted: m });

    stopTyping();
    stopEmoji();

  } catch (err) {
    console.error("‚ùå Xylo AI Error:", err);
    await conn.sendMessage(from, { text: "‚ö†Ô∏è Xylo AI error occurred." }, { quoted: m });
  }
});
