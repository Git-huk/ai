const axios = require('axios');
const { cmd } = require('../command');
const config = require("../config");
const { setConfig, getConfig } = require("../lib/configdb");
const fs = require('fs');
const path = require('path');
const { downloadTempMedia, cleanupTemp } = require("../lib/media-utils");

const simulateTyping = async (conn, jid, ms = 2000) => {
  await conn.sendPresenceUpdate('composing', jid);
  await new Promise(resolve => setTimeout(resolve, ms));
  await conn.sendPresenceUpdate('paused', jid);
};

let AI_STATE = {
  IB: "false",
  GC: "false"
};

cmd({
  pattern: "chatbot",
  alias: ["xylo"],
  desc: "Enable or disable AI chatbot responses",
  category: "ai",
  filename: __filename,
  react: "ü§ñ"
}, async (conn, mek, m, { from, args, isOwner, reply }) => {
  if (!isOwner) return reply("‚ùå Only the bot owner can use this command.");

  const mode = args[0]?.toLowerCase();
  const target = args[1]?.toLowerCase();

  if (mode === "on") {
    if (!target || target === "all") {
      AI_STATE.IB = "true";
      AI_STATE.GC = "true";
    } else if (target === "pm") {
      AI_STATE.IB = "true";
    } else if (target === "gc") {
      AI_STATE.GC = "true";
    }
    await setConfig("AI_STATE", JSON.stringify(AI_STATE));
    return reply("‚úÖ Xylo AI enabled for " + (target || "all") + " chats.");
  } else if (mode === "off") {
    if (!target || target === "all") {
      AI_STATE.IB = "false";
      AI_STATE.GC = "false";
    } else if (target === "pm") {
      AI_STATE.IB = "false";
    } else if (target === "gc") {
      AI_STATE.GC = "false";
    }
    await setConfig("AI_STATE", JSON.stringify(AI_STATE));
    return reply("‚ùå Xylo AI disabled for " + (target || "all") + " chats.");
  } else {
    return reply(`ü§ñ *Xylo AI Control Panel*

üì• PM: ${AI_STATE.IB === "true" ? "‚úÖ On" : "‚ùå Off"}
üë• Group: ${AI_STATE.GC === "true" ? "‚úÖ On" : "‚ùå Off"}

Usage:
${config.PREFIX}chatbot on|off all|pm|gc`);
  }
});

(async () => {
  const saved = await getConfig("AI_STATE");
  if (saved) AI_STATE = JSON.parse(saved);
})();

cmd({
  on: "body"
}, async (conn, m, store, {
  from,
  body,
  isGroup,
  sender,
  reply
}) => {
  try {
    if (m.key.fromMe || body?.startsWith(config.PREFIX)) return;

    const allowed = isGroup ? AI_STATE.GC === "true" : AI_STATE.IB === "true";
    if (!allowed) return;

    const quoted = m?.message?.extendedTextMessage?.contextInfo?.participant;
    const botJid = conn.user.id.split(':')[0] + '@s.whatsapp.net';
    const mentionedBot = body?.toLowerCase().includes("say it") || quoted === botJid;

    if (!mentionedBot && !m?.message?.audioMessage) return;

    const isAudio = !!m.message.audioMessage;
    let promptText = body;

    // üß† Audio Transcription (currently skipped because Whisper is down)
    if (isAudio) {
      const audioBuffer = await conn.downloadAndSaveMediaMessage(m, "./tmp/voice.ogg");
      promptText = "Hello"; // default fallback
      fs.unlinkSync(audioBuffer);
    }

    // üñºÔ∏è Image Generation
    if (body.toLowerCase().startsWith("draw ")) {
      const prompt = body.slice(5).trim();
      const { data: draw } = await axios.post('https://xylo-ai.onrender.com/draw', {
        prompt
      });
      const imgPath = await downloadTempMedia(draw.imageUrl, 'xylo_img.jpg');
      await conn.sendMessage(from, { image: fs.readFileSync(imgPath), caption: "üñºÔ∏è Generated by ùïè è ü·¥è" }, { quoted: m });
      cleanupTemp(imgPath);
      return;
    }

    // ‚å®Ô∏è Simulate Typing
    const duration = Math.floor(Math.random() * 1500) + 1500;
    await simulateTyping(conn, from, duration);

    // ü§ñ AI Chat Response
    const { data } = await axios.post('https://xylo-ai.onrender.com/ask', {
      userId: sender,
      message: promptText
    });

    if (data?.reply) {
      await conn.sendMessage(from, { text: data.reply, ai: true }, { quoted: m });

      // üîä Voice Reply
      if (isAudio || body.toLowerCase().includes("say it")) {
        const { data: voiceRes } = await axios.post('https://xylo-ai.onrender.com/voice', {
          text: data.reply
        });

        const tempPath = path.join(__dirname, '../tmp/xylo_voice.mp3');
        const writer = fs.createWriteStream(tempPath);
        const audioRes = await axios.get(voiceRes.audioUrl, { responseType: "stream" });

        audioRes.data.pipe(writer);
        await new Promise((resolve, reject) => {
          writer.on("finish", resolve);
          writer.on("error", reject);
        });

        await conn.sendMessage(from, {
          audio: fs.readFileSync(tempPath),
          mimetype: 'audio/mp4',
          ptt: true
        }, { quoted: m });

        fs.unlinkSync(tempPath);
      }
    } else {
      reply("‚ö†Ô∏è No reply from Xylo.");
    }
  } catch (err) {
    console.error("AI Chat Error:", err.message);
    reply("‚ö†Ô∏è Xylo AI error occurred.");
  }
});
