const axios = require('axios');
const { cmd } = require('../command');
const config = require("../config");
const { setConfig, getConfig } = require("../lib/configdb");
const fs = require('fs');
const { downloadTempMedia, cleanupTemp } = require("../lib/media-utils");

// Typing simulator
const simulateTyping = async (conn, jid) => {
  await conn.sendPresenceUpdate('composing', jid);
  let stopped = false;
  const interval = setInterval(() => {
    if (!stopped) conn.sendPresenceUpdate('composing', jid);
  }, 5000);
  return () => {
    clearInterval(interval);
    conn.sendPresenceUpdate('paused', jid);
    stopped = true;
  };
};

// Emoji typing animation
const animatedTyping = async (conn, jid, msgKey) => {
  const emojis = ["üí≠", "üí¨", "‚úçÔ∏è"];
  let index = 0;
  let stopped = false;
  const interval = setInterval(() => {
    if (stopped) return;
    conn.sendMessage(jid, { react: { text: emojis[index], key: msgKey } });
    index = (index + 1) % emojis.length;
  }, 1000);
  return () => {
    clearInterval(interval);
    conn.sendMessage(jid, { react: { text: "ü§ñ", key: msgKey } });
    stopped = true;
  };
};

// AI config state
let AI_STATE = {
  IB: "false",
  GC: "false"
};

// Toggle AI
cmd({
  pattern: "chatbot",
  alias: ["xylo"],
  desc: "Enable or disable AI chatbot responses",
  category: "ai",
  filename: __filename,
  react: "ü§ñ"
}, async (conn, mek, m, { from, args, isOwner, reply }) => {
  if (!isOwner) return reply("‚ùå Only the bot owner can use this command.");
  const mode = args[0]?.toLowerCase();
  const target = args[1]?.toLowerCase();

  if (mode === "on") {
    if (!target || target === "all") {
      AI_STATE.IB = "true";
      AI_STATE.GC = "true";
    } else if (target === "pm") {
      AI_STATE.IB = "true";
    } else if (target === "gc") {
      AI_STATE.GC = "true";
    }
    await setConfig("AI_STATE", JSON.stringify(AI_STATE));
    return reply("‚úÖ Xylo AI enabled for " + (target || "all") + " chats.");
  } else if (mode === "off") {
    if (!target || target === "all") {
      AI_STATE.IB = "false";
      AI_STATE.GC = "false";
    } else if (target === "pm") {
      AI_STATE.IB = "false";
    } else if (target === "gc") {
      AI_STATE.GC = "false";
    }
    await setConfig("AI_STATE", JSON.stringify(AI_STATE));
    return reply("‚ùå Xylo AI disabled for " + (target || "all") + " chats.");
  } else {
    return reply(`ü§ñ *Xylo AI Control Panel*

üì• PM: ${AI_STATE.IB === "true" ? "‚úÖ On" : "‚ùå Off"}
üë• Group: ${AI_STATE.GC === "true" ? "‚úÖ On" : "‚ùå Off"}

Usage:
${config.PREFIX}chatbot on|off all|pm|gc`);
  }
});

// Load config on startup
(async () => {
  const saved = await getConfig("AI_STATE");
  if (saved) AI_STATE = JSON.parse(saved);
})();

// Auto AI reply
cmd({
  on: "body"
}, async (conn, m, store, { from, body, isGroup, sender, reply }) => {
  try {
    if (!body || typeof body !== "string") return;
    const botJid = conn.user.id.split(':')[0] + '@s.whatsapp.net';
    const msgKey = m.key;

    const contextInfo = m?.message?.extendedTextMessage?.contextInfo || {};
    const isMentioned = contextInfo.mentionedJid?.includes(botJid);
    const isQuoted = contextInfo.participant === botJid || contextInfo.stanzaId === msgKey.id;

    const isOwnerMessage = msgKey?.fromMe;
    const isCmd = body.startsWith(config.PREFIX);
    const allowed = isGroup ? AI_STATE.GC === "true" : AI_STATE.IB === "true";
    if (isOwnerMessage || isCmd || !allowed || (!isMentioned && !isQuoted && !isGroup)) return;

    // Draw image if starts with "draw "
    if (body.toLowerCase().startsWith("draw ")) {
      await conn.sendMessage(from, { react: { text: "üé®", key: msgKey } });
      const prompt = body.slice(5).trim();
      const { data: draw } = await axios.post('https://xylo-ai.onrender.com/draw', { prompt });

      const imgPath = await downloadTempMedia(draw.imageUrl, 'xylo_img.jpg');
      await conn.sendMessage(from, {
        image: fs.readFileSync(imgPath),
        caption: "üñºÔ∏è Generated by ùïè è ü·¥è"
      }, { quoted: m });
      cleanupTemp(imgPath);
      return;
    }

    // Simulate typing + emoji animation
    const stopEmoji = await animatedTyping(conn, from, msgKey);
    const stopTyping = await simulateTyping(conn, from);

    // AI response
    const userId = sender.replace(/\D/g, ''); // 234818xxx...
    const res = await axios.post('https://xylo-ai.onrender.com/ask', {
      userId,
      message: body
    });

    const replyText = res.data?.reply;
    if (replyText) {
      await conn.sendMessage(from, { text: replyText }, { quoted: m });
    } else {
      await conn.sendMessage(from, { text: "‚ö†Ô∏è Xylo heard you, but couldn‚Äôt reply.", quoted: m });
    }

    stopTyping();
    stopEmoji();

  } catch (err) {
    console.error("‚ùå AI Error:", err);
    reply("‚ö†Ô∏è Xylo AI error occurred.");
  }
});
