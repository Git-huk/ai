const axios = require('axios');
const { cmd } = require('../command');
const config = require("../config");
const { setConfig, getConfig } = require("../lib/configdb");
const fs = require('fs');
const path = require('path');
const { downloadTempMedia, cleanupTemp } = require("../lib/media-utils");

const simulateTyping = async (conn, jid, ms = 2000) => {
  await conn.sendPresenceUpdate('composing', jid);
  await new Promise(resolve => setTimeout(resolve, ms));
  await conn.sendPresenceUpdate('paused', jid);
};

let AI_STATE = { IB: "false", GC: "false" };

// Load AI state on startup
(async () => {
  const saved = await getConfig("AI_STATE");
  if (saved) AI_STATE = JSON.parse(saved);
})();

// üì• /chatbot interactive command (with smart menu)
cmd({
  pattern: "chatbot",
  alias: ["xylo"],
  desc: "Control AI chatbot mode",
  category: "ai",
  filename: __filename,
  react: "ü§ñ"
}, async (conn, mek, m, { from, isOwner, reply }) => {
  if (!isOwner) return reply("‚ùå Only the bot owner can use this command.");

  const text = `> *Xylo AI Chatbot Settings*

Current Status:
üì• PM: ${AI_STATE.IB === "true" ? "‚úÖ Enabled" : "‚ùå Disabled"}
üë• Group: ${AI_STATE.GC === "true" ? "‚úÖ Enabled" : "‚ùå Disabled"}

_Reply with:_
1. Enable for PM only
2. Enable for Groups only
3. Enable for All
4. Disable All`;

  const sentMsg = await conn.sendMessage(from, {
    image: { url: "https://i.postimg.cc/rFV2pJW5/IMG-20250603-WA0017.jpg" },
    caption: text
  }, { quoted: mek });

  const messageID = sentMsg.key.id;

  const handler = async (msgData) => {
    try {
      const msg = msgData.messages?.[0];
      if (!msg?.message) return;

      const isReply = msg.message?.extendedTextMessage?.contextInfo?.stanzaId === messageID;
      if (!isReply) return;

      const userText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || "";
      const jid = msg.key.remoteJid;

      let response = "";
      switch (userText.trim()) {
        case "1":
          AI_STATE.IB = "true"; AI_STATE.GC = "false"; response = "‚úÖ Enabled for PM only"; break;
        case "2":
          AI_STATE.IB = "false"; AI_STATE.GC = "true"; response = "‚úÖ Enabled for Groups only"; break;
        case "3":
          AI_STATE.IB = "true"; AI_STATE.GC = "true"; response = "‚úÖ Enabled for All Chats"; break;
        case "4":
          AI_STATE.IB = "false"; AI_STATE.GC = "false"; response = "‚ùå Disabled in All Chats"; break;
        default:
          await conn.sendMessage(jid, { text: "‚ö†Ô∏è Invalid option. Use 1 to 4 only." }, { quoted: msg });
          return;
      }

      await setConfig("AI_STATE", JSON.stringify(AI_STATE));
      await conn.sendMessage(jid, { text: response }, { quoted: msg });

      conn.ev.off("messages.upsert", handler);
    } catch (err) {
      console.error("AI Menu Error:", err);
    }
  };

  conn.ev.on("messages.upsert", handler);
  setTimeout(() => conn.ev.off("messages.upsert", handler), 10 * 60 * 1000); // Clean up after 10 mins
});

// ü§ñ AI Chat Handler
cmd({
  on: "body"
}, async (conn, m, store, { from, body, isGroup, sender, reply }) => {
  try {
    if (m.key.fromMe || body?.startsWith(config.PREFIX)) return;

    const allowed = isGroup ? AI_STATE.GC === "true" : AI_STATE.IB === "true";
    if (!allowed) return;

    const botJid = conn.user.id.split(":")[0] + "@s.whatsapp.net";
    const isMentioned = body.toLowerCase().includes("say it") ||
                        m?.message?.extendedTextMessage?.contextInfo?.mentionedJid?.includes(botJid) ||
                        m?.message?.extendedTextMessage?.contextInfo?.participant === botJid;

    const isAudio = !!m.message.audioMessage;
    if (!isAudio && !isMentioned && isGroup) return;

    let promptText = body;

    // üñºÔ∏è Draw image
    if (body.toLowerCase().startsWith("draw ")) {
      const prompt = body.slice(5).trim();
      const { data: draw } = await axios.post('https://xylo-ai.onrender.com/draw', { prompt });
      const imgPath = await downloadTempMedia(draw.imageUrl, 'xylo_img.jpg');
      await conn.sendMessage(from, {
        image: fs.readFileSync(imgPath),
        caption: "üñºÔ∏è Generated by ùïè è ü·¥è"
      }, { quoted: m });
      cleanupTemp(imgPath);
      return;
    }

    // üß† Voice prompt (transcription skipped)
    if (isAudio) {
      const audioPath = await conn.downloadAndSaveMediaMessage(m, "./tmp/voice.ogg");
      promptText = "Hello"; // fallback text
      fs.unlinkSync(audioPath);
    }

    // ‚å®Ô∏è Typing simulation
    await simulateTyping(conn, from, Math.floor(Math.random() * 1500) + 1500);

    // üß† Get AI response
    const { data } = await axios.post("https://xylo-ai.onrender.com/ask", {
      userId: sender.split("@")[0],
      message: promptText
    });

    if (!data?.reply) return reply("‚ö†Ô∏è No reply from Xylo.");

    await conn.sendMessage(from, { text: data.reply, ai: true }, { quoted: m });

    // üîä Voice response if requested
    if (isAudio || body.toLowerCase().includes("say it")) {
      const { data: voiceData } = await axios.post("https://xylo-ai.onrender.com/voice", {
        text: data.reply
      });

      const filePath = path.join(__dirname, '../tmp/xylo_voice.mp3');
      const writer = fs.createWriteStream(filePath);
      const stream = await axios.get(voiceData.audioUrl, { responseType: "stream" });
      stream.data.pipe(writer);

      await new Promise((res, rej) => {
        writer.on("finish", res);
        writer.on("error", rej);
      });

      await conn.sendMessage(from, {
        audio: fs.readFileSync(filePath),
        mimetype: "audio/mp4",
        ptt: true
      }, { quoted: m });

      fs.unlinkSync(filePath);
    }
  } catch (err) {
    console.error("Chatbot error:", err);
    reply("‚ö†Ô∏è Error occurred while using Xylo AI.");
  }
});
